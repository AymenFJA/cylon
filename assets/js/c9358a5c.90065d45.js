(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{94:function(t,n,e){"use strict";e.r(n),e.d(n,"frontMatter",(function(){return s})),e.d(n,"metadata",(function(){return l})),e.d(n,"toc",(function(){return i})),e.d(n,"default",(function(){return p}));var a=e(3),r=e(8),o=(e(0),e(98)),s={id:"cpp",title:"C++"},l={unversionedId:"cpp",id:"cpp",isDocsHomePage:!1,title:"C++",description:"cylon::CylonContext",source:"@site/docs/cpp.md",sourceDirName:".",slug:"/cpp",permalink:"/docs/cpp",editUrl:"https://github.com/cylondata/cylon/edit/master/docs/docs/cpp.md",version:"current",frontMatter:{id:"cpp",title:"C++"},sidebar:"someSidebar",previous:{title:"Architecture",permalink:"/docs/arch"},next:{title:"PyCylon",permalink:"/docs/python"}},i=[{value:"<code>cylon::CylonContext</code>",id:"cyloncyloncontext",children:[{value:"Initialization",id:"initialization",children:[]},{value:"Context methods",id:"context-methods",children:[]}]},{value:"<code>cylon::Table</code>",id:"cylontable",children:[{value:"Reading tables",id:"reading-tables",children:[]},{value:"Writing tables",id:"writing-tables",children:[]},{value:"<code>cylon::Table</code> API",id:"cylontable-api",children:[]},{value:"C++ Examples",id:"c-examples",children:[]}]}],c={toc:i};function p(t){var n=t.components,e=Object(r.a)(t,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,e,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"cyloncyloncontext"},Object(o.b)("inlineCode",{parentName:"h2"},"cylon::CylonContext")),Object(o.b)("p",null,"The entry point to cylon operations"),Object(o.b)("h3",{id:"initialization"},"Initialization"),Object(o.b)("p",null,"Local initialization"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-c++"},"  auto ctx = cylon::CylonContext::Init();\n")),Object(o.b)("p",null,"Distributed initialization"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-c++"},"  auto mpi_config = new cylon::net::MPIConfig();\n  auto ctx = cylon::CylonContext::InitDistributed(mpi_config);\n")),Object(o.b)("h3",{id:"context-methods"},"Context methods"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},'  /**\n   * Completes and closes all operations under the context\n   */\n  void Finalize();\n\n  /**\n   * Adds a configuration\n   * @param <std::string> key\n   * @param <std::string> value\n   */\n  void AddConfig(const std::string &key, const std::string &value);\n\n  /**\n   * Returns a configuration\n   * @param <std::string> key\n   * @param <std::string> def Default value\n   * @return <std::string> configuration value\n   */\n  std::string GetConfig(const std::string &key, const std::string &def = "");\n\n  /**\n   * Returns the Communicator instance\n   * @return <cylon::net::Communicator>\n   */\n  net::Communicator *GetCommunicator() const;\n\n  /**\n   * Sets a Communicator\n   * @param <cylon::net::Communicator*> pointer to another communicator\n   */\n  void setCommunicator(net::Communicator *communicator1);\n\n  /**\n   * Sets if distributed\n   * @param <bool> distributed\n   */\n  void setDistributed(bool distributed);\n\n  /**\n   * Returns the local rank\n   * @return rank <int>\n   */\n  int GetRank();\n\n  /**\n   * Returns the world size\n   * @return world size <int>\n   */\n  int GetWorldSize();\n\n  /**\n   * Returns the neighbors in the world\n   * @param include_self\n   * @return a std::vector<int> of ranks\n   */\n  vector<int> GetNeighbours(bool include_self);\n\n  /**\n   * Returns memory pool\n   * @return <cylon::MemoryPool>\n   */\n  cylon::MemoryPool *GetMemoryPool();\n\n  /**\n   * Sets a memory pool\n   * @param <cylon::MemoryPool> mem_pool\n   */\n  void SetMemoryPool(cylon::MemoryPool *mem_pool);\n\n')),Object(o.b)("h2",{id:"cylontable"},Object(o.b)("inlineCode",{parentName:"h2"},"cylon::Table")),Object(o.b)("h3",{id:"reading-tables"},"Reading tables"),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"cylon::Table")," can be created from a csv file as follows. "),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},'std::shared_ptr<cylon::Table> table1;\nauto read_options = CSVReadOptions();\nauto status = cylon::FromCSV(ctx, "/path/to/csv", table1, read_options))\n')),Object(o.b)("p",null,"Read a set of tables using threads,"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},'std::shared_ptr<cylon::Table> table1, table2;\nauto read_options = CSVReadOptions().UseThreads(true);\nauto status = cylon::FromCSV(ctx, {"/path/to/csv1.csv", "/path/to/csv2.csv"}, {table1, table2}, read_options);\n')),Object(o.b)("p",null,"An ",Object(o.b)("inlineCode",{parentName:"p"},"arrow::Table")," can be imported as follows,"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"std::shared_ptr<cylon::Table> table1;\nstd::shared_ptr<arrow::Table> some_arrow_table = ...;\nauto status = cylon::Table::FromArrowTable(ctx, some_arrow_table, table1);\n")),Object(o.b)("h3",{id:"writing-tables"},"Writing tables"),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"cylon::Table")," can be written to a CSV file as follows, "),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},'std::shared_ptr<cylon::Table> table1; \n...\nauto write_options = cylon::io::config::CSVWriteOptions();\nauto status = WriteCSV(table1, "/path/to/csv", write_options);\n')),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"cylon::Table")," can be coverted into an ",Object(o.b)("inlineCode",{parentName:"p"},"arrow::Table")," by simply, "),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"std::shared_ptr<arrow::Table> some_arrow_table;\nstd::shared_ptr<cylon::Table> table1; \n...\nauto status = table1->ToArrowTable(some_arrow_table);\n")),Object(o.b)("h3",{id:"cylontable-api"},Object(o.b)("inlineCode",{parentName:"h3"},"cylon::Table")," API"),Object(o.b)("h4",{id:"cylontable-functions"},Object(o.b)("inlineCode",{parentName:"h4"},"cylon::Table")," Functions"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"/**\n* Create a table from an arrow table,\n* @param table\n* @return\n*/\nstatic Status FromArrowTable(std::shared_ptr<cylon::CylonContext> &ctx,\n                           std::shared_ptr<arrow::Table> &table,\n                           std::shared_ptr<Table> &tableOut);\n\n/**\n* Create a table from cylon columns\n* @param ctx\n* @param columns\n* @param tableOut\n* @return\n*/\nstatic Status FromColumns(std::shared_ptr<cylon::CylonContext> &ctx,\n                        std::vector<std::shared_ptr<Column>> &&columns,\n                        std::shared_ptr<Table> &tableOut);\n\n/**\n* Write the table as a CSV\n* @param path file path\n* @return the status of the operation\n*/\nStatus WriteCSV(const std::string &path,\n              const cylon::io::config::CSVWriteOptions &options = cylon::io::config::CSVWriteOptions());\n\n/**\n* Create a arrow table from this data structure\n* @param output arrow table\n* @return the status of the operation\n*/\nStatus ToArrowTable(std::shared_ptr<arrow::Table> &output);\n\n/**\n* Print the col range and row range\n* @param col1 start col\n* @param col2 end col\n* @param row1 start row\n* @param row2 end row\n* @param out the stream\n* @param delimiter delimiter between values\n* @param use_custom_header custom header\n* @param headers the names of custom header\n* @return true if print is successful\n*/\nStatus PrintToOStream(int col1,  int col2,  int row1,  int row2,  std::ostream &out,\n                      char delimiter = ',',\n                      bool use_custom_header = false,\n                      const std::vector<std::string> &headers = {});\n\n/**\n* Get the number of columns in the table\n* @return numbre of columns\n*/\nint32_t Columns();\n\n/**\n* Get the number of rows in this table\n* @return number of rows in the table\n*/\nint64_t Rows();\n\n/**\n* Print the complete table\n*/\nvoid Print();\n\n/**\n* Print the table from row1 to row2 and col1 to col2\n* @param row1 first row to start printing (including)\n* @param row2 end row to stop printing (including)\n* @param col1 first column to start printing (including)\n* @param col2 end column to stop printing (including)\n*/\nvoid Print(int row1, int row2, int col1, int col2);\n\n/**\n* Get the underlying arrow table\n* @return the arrow table\n*/\nstd::shared_ptr<arrow::Table> get_table();\n\n/**\n* Clears the table\n*/\nvoid Clear();\n\n/**\n* Returns the cylon Context\n* @return\n*/\nstd::shared_ptr<cylon::CylonContext> GetContext();\n\n/**\n* Get column names of the table\n* @return vector<string>\n*/\nstd::vector<std::string> ColumnNames();\n\n/**\n* Set to true to free the memory of this table when it is not needed\n*/\nvoid retainMemory(bool retain);\n\n/**\n* Returns if this table retains data after any operation performed on it\n* @return \n*/\nbool IsRetain() const;\n\n/**\n* Get the i'th column from the table\n* @param index\n* @return\n*/\nstd::shared_ptr<Column> GetColumn(int32_t index) const;\n\n/**\n* Get the column vector of the table\n* @return\n*/\nstd::vector<std::shared_ptr<cylon::Column>> GetColumns() const;\n")),Object(o.b)("h4",{id:"cylontable-operations"},Object(o.b)("inlineCode",{parentName:"h4"},"cylon::Table")," Operations"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"/**\n   * Create a table by reading a csv file\n   * @param path file path\n   * @return a pointer to the table\n   */\nStatus FromCSV(std::shared_ptr<cylon::CylonContext> &ctx, const std::string &path,\n               std::shared_ptr<Table> &tableOut,\n               const cylon::io::config::CSVReadOptions &options = cylon::io::config::CSVReadOptions());\n\n/**\n * Read multiple CSV files into multiple tables. If threading is enabled, the tables will be read\n * in parallel\n * @param ctx\n * @param paths\n * @param tableOuts\n * @param options\n * @return\n */\nStatus FromCSV(std::shared_ptr<cylon::CylonContext> &ctx, const std::vector<std::string> &paths,\n               const std::vector<std::shared_ptr<Table> *> &tableOuts,\n               io::config::CSVReadOptions options = cylon::io::config::CSVReadOptions());\n\n/**\n   * Merge the set of tables to create a single table\n   * @param tables\n   * @return new merged table\n   */\nStatus Merge(std::shared_ptr<cylon::CylonContext> &ctx,\n             const std::vector<std::shared_ptr<cylon::Table>> &tables,\n             std::shared_ptr<Table> &tableOut);\n\n/**\n   * Do the join with the right table\n   * @param left the left table\n   * @param right the right table\n   * @param joinConfig the join configurations\n   * @param output the final table\n   * @return success\n   */\nStatus Join(std::shared_ptr<Table> &left, std::shared_ptr<Table> &right,\n            cylon::join::config::JoinConfig join_config,\n            std::shared_ptr<Table> &output);\n\n/**\n * Similar to local join, but performs the join in a distributed fashion\n * @param left\n * @param right\n * @param join_config\n * @param output\n * @return <cylon::Status>\n */\nStatus DistributedJoin(std::shared_ptr<Table> &left, std::shared_ptr<Table> &right,\n                       cylon::join::config::JoinConfig join_config,\n                       std::shared_ptr<Table> &output);\n\n/**\n * Performs union with the passed table\n * @param first\n * @param second\n * @param output\n * @return <cylon::Status>\n */\nStatus Union(std::shared_ptr<Table> &first, std::shared_ptr<Table> &second,\n             std::shared_ptr<Table> &output);\n\n/**\n * Similar to local union, but performs the union in a distributed fashion\n * @param first\n * @param second\n * @param output\n * @return <cylon::Status>\n */\nStatus DistributedUnion(std::shared_ptr<Table> &first, std::shared_ptr<Table> &second,\n                        std::shared_ptr<Table> &out);\n\n/**\n * Performs subtract/difference with the passed table\n * @param first\n * @param second\n * @param output\n * @return <cylon::Status>\n */\nStatus Subtract(std::shared_ptr<Table> &first,\n                std::shared_ptr<Table> &second, std::shared_ptr<Table> &out);\n\n/**\n * Similar to local subtract/difference, but performs in a distributed fashion\n * @param first\n * @param second\n * @param output\n * @return <cylon::Status>\n */\nStatus DistributedSubtract(std::shared_ptr<Table> &left, std::shared_ptr<Table> &right,\n                           std::shared_ptr<Table> &out);\n\n/**\n * Performs intersection with the passed table\n * @param first\n * @param second\n * @param output\n * @return <cylon::Status>\n */\nStatus Intersect(std::shared_ptr<Table> &first,\n                 std::shared_ptr<Table> &second, std::shared_ptr<Table> &output);\n\n/**\n * Similar to local intersection, but performs in a distributed fashion\n * @param first\n * @param second\n * @param output\n * @return <cylon::Status>\n */\nStatus DistributedIntersect(std::shared_ptr<Table> &left, std::shared_ptr<Table> &right,\n                            std::shared_ptr<Table> &out);\n\n/**\n * Shuffles a table based on hashes\n * @param table\n * @param hash_col_idx vector of column indicies that needs to be hashed\n * @param output\n * @return\n */\nStatus Shuffle(std::shared_ptr<cylon::Table> &table, const std::vector<int> &hash_col_idx,\n               std::shared_ptr<cylon::Table> &output);\n\n/**\n * Partition the table based on the hash\n * @param hash_columns the columns use for has\n * @param num_partitions number partitions\n * @return new set of tables each with the new partition\n */\nStatus HashPartition(std::shared_ptr<cylon::Table> &table,\n                     const std::vector<int> &hash_columns,\n                     int num_partitions,\n                     std::unordered_map<int, std::shared_ptr<cylon::Table>> *output);\n\n/**\n * Sort the table according to the given column, this is a local sort (if the table has chunked columns, they will\n * be merged in the output table)\n * @param sort_column\n * @return new table sorted according to the sort column\n */\nStatus Sort(std::shared_ptr<cylon::Table> &table, int sort_column, std::shared_ptr<Table> &output);\n\n/**\n * Distributed sort the table according to the given column\n * @param sort_column\n * @return new table sorted according to the sort column\n */\nstruct SortOptions {\n  bool ascending;\n  uint32_t num_bins;\n  uint64_t num_samples;\n  \n  static SortOptions Defaults();\n};\nStatus DistributedSort(std::shared_ptr<cylon::Table> &table,\n                       int sort_column,\n                       std::shared_ptr<Table> &output,\n                       SortOptions sort_options = SortOptions::Defaults());\n\n/**\n * Filters out rows based on the selector function\n * @param table\n * @param selector lambda function returning a bool\n * @param output\n * @return\n */\nStatus Select(std::shared_ptr<cylon::Table> &table, const std::function<bool(cylon::Row)> &selector, std::shared_ptr<Table> &output);\n\n/**\n * Creates a View of an existing table by dropping one or more columns\n * @param table\n * @param project_columns\n * @param output\n * @return\n */\nStatus Project(std::shared_ptr<cylon::Table> &table, const std::vector<int64_t> &project_columns, std::shared_ptr<Table> &output);\n")),Object(o.b)("h3",{id:"c-examples"},"C++ Examples"),Object(o.b)("p",null,"Following is a simple C++ API example. "),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},'#include <glog/logging.h>\n\n#include <net/mpi/mpi_communicator.hpp>\n#include <ctx/cylon_context.hpp>\n#include <table.hpp>\n\n#define CHECK_STATUS(status, msg) \\\n  if (!status.is_ok()) {          \\\n    LOG(ERROR) << msg << " " << status.get_msg(); \\\n    ctx->Finalize();              \\\n    return 1;                     \\\n  }                               \n\nint main() {\n\n  auto mpi_config = cylon::net::MPIConfig::Make();\n  auto ctx = cylon::CylonContext::InitDistributed(mpi_config);\n  const int rank = ctx->GetRank() + 1;\n\n  const std::string csv1 = "/tmp/user_device_tm_" + std::to_string(rank) + ".csv";\n  const std::string csv2 = "/tmp/user_usage_tm_" + std::to_string(rank) + ".csv";\n\n  std::shared_ptr<cylon::Table> first_table, second_table, joined_table;\n  cylon::Status status;\n\n  status = cylon::FromCSV(ctx, csv1, first_table);\n  CHECK_STATUS(status, "Reading csv1 failed!")\n\n  status = cylon::FromCSV(ctx, csv2, second_table);\n  CHECK_STATUS(status, "Reading csv2 failed!")\n\n  auto join_config = cylon::join::config::JoinConfig::InnerJoin(0, 3);\n  status = cylon::DistributedJoin(first_table, second_table, join_config, joined_table);\n  CHECK_STATUS(status, "Join failed!")\n\n  LOG(INFO) << "First table had : " << first_table->Rows() << " and Second table had : "\n            << second_table->Rows() << ", Joined has : " << joined_table->Rows();\n\n  ctx->Finalize();\n  return 0;\n}\n')),Object(o.b)("p",null,"Further examples can be found in ",Object(o.b)("a",{parentName:"p",href:"https://github.com/cylondata/cylon/tree/master/cpp/src/examples"},"Cylon examples in Github"),"."))}p.isMDXComponent=!0},98:function(t,n,e){"use strict";e.d(n,"a",(function(){return u})),e.d(n,"b",(function(){return m}));var a=e(0),r=e.n(a);function o(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function s(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,a)}return e}function l(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?s(Object(e),!0).forEach((function(n){o(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):s(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function i(t,n){if(null==t)return{};var e,a,r=function(t,n){if(null==t)return{};var e,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)e=o[a],n.indexOf(e)>=0||(r[e]=t[e]);return r}(t,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)e=o[a],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(r[e]=t[e])}return r}var c=r.a.createContext({}),p=function(t){var n=r.a.useContext(c),e=n;return t&&(e="function"==typeof t?t(n):l(l({},n),t)),e},u=function(t){var n=p(t.components);return r.a.createElement(c.Provider,{value:n},t.children)},d={inlineCode:"code",wrapper:function(t){var n=t.children;return r.a.createElement(r.a.Fragment,{},n)}},b=r.a.forwardRef((function(t,n){var e=t.components,a=t.mdxType,o=t.originalType,s=t.parentName,c=i(t,["components","mdxType","originalType","parentName"]),u=p(e),b=a,m=u["".concat(s,".").concat(b)]||u[b]||d[b]||o;return e?r.a.createElement(m,l(l({ref:n},c),{},{components:e})):r.a.createElement(m,l({ref:n},c))}));function m(t,n){var e=arguments,a=n&&n.mdxType;if("string"==typeof t||a){var o=e.length,s=new Array(o);s[0]=b;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=t,l.mdxType="string"==typeof t?t:a,s[1]=l;for(var c=2;c<o;c++)s[c]=e[c];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,e)}b.displayName="MDXCreateElement"}}]);